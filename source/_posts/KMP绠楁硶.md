---
title: KMP算法
date: 2022-03-17 21:29:04
tags:
---

首发于[CSDN](https://editor.csdn.net/md/?articleId=123290394)

# KMP算法

## next数组构建
> **定义：** 对于字符串$p$，$next[i]$表示$p$在$[0, i]$上的子串的最长相同前后缀长度

> **暴力求解：** 很明显，可以在$[0, i)$上枚举长度来构建$next$，此时算法复杂度为$O(m^2)$，$m$为$p$的长度

> **优化求解：** 见到最长两字容易想到使用递推也就是动态规划去求解，此时状态就是next数组的定义；求解$next[i]$时已知字串$[0, i-1]$的最长相同前后缀长度$next[i-1]=j$，也就是说该子串对应前缀为子串$[0, j)$；此时出现两种情况：

+$ (1) $p[j]=p[i]$，有$next[i]=next[i-1]+1;$


> (2) $p[j] \neq p[i]$，此时需要==不断缩短子串$[0, j)$，找到子串$[0, i-1]$上的次长相同前后缀长度==，但我们只知道最长相同前后缀长度$next[i-1]$；但不难由$next[i-1]=j$得子串$[0, j)$等于子串$[i-j, i-1]$，而子串$[0, i-1]$的次长相同前后缀的前缀必定落在子串$[0, j)$上、后缀必定落在子串$[i-j, i-1]$上，由于这两个串相等，==求解子串$[0, i-1]$次长相同前后缀问题可转化为求解子串$[0, j)$的最长相同前后缀，也就是$next[j-1]$==；不断递归$j=next[j-1]$直至$p[j]==p[i]$或$j==0$，要么没找到相同字符，此时$next[i]=0$，要么找到了，此时$next[i]=j+1$；