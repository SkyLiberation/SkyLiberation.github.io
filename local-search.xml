<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pytorch Loss优化</title>
    <link href="/2022/07/15/Pytorch%20Loss/"/>
    <url>/2022/07/15/Pytorch%20Loss/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch-loss优化">Pytorch Loss优化</h1><span id="more"></span><h2 id="问题引入">问题引入</h2><p>考虑这么一个网络的优化： <img src="/img/Loss/network.png" alt="network" /> 整个网络由3个loss优化(<code>loss_cls_content, loss_adv, loss_cls_style</code>)，其中<code>loss_cls_content</code>只优化<code>Feature Extractor(Content) Block1, Feature Extractor(Content) Block1, ClsHead(Content)</code>（黄色虚线框框住的模块）、<code>loss_adv</code>只优化<code>Feature Extractor(Content) Block1</code>（红色虚线框框住的模块）、<code>loss_cls_style</code>只优化<code>Feature Extractor(Content) Block2, ClsHead(Style)</code>（绿色虚线框框住的模块）。 ## 如何进行梯度回传 定义三个优化器<code>optimizer_content, optimizer_style, optimizer_adv</code>，分别优化三个虚线框内模块的参数；</p><p><strong>容易想到这么一种优化方法：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果不考虑使用detach()进行模块隔绝（实际上detach对这个网络的优化也无能为力），三个loss在回传过程中都会影响到不希望影响到的模块</span><br><span class="hljs-comment"># 考虑使用三个优化器，只优化对应模块的参数，三个loss分别回传，优化前都会进行梯度归零、回传后马上更新权值，即可达到想要的优化效果</span><br>optimizer_style.zero_grad()<br>loss_cls_style.backward(retain_graph=<span class="hljs-literal">True</span>)<br>optimizer_style.step()<br><br>optimizer_adv.zero_grad()<br>loss_adv.backward(retain_graph=<span class="hljs-literal">True</span>)<br>optimizer_adv.step()<br><br>optimizer_content.zero_grad()<br>loss_cls_content.backward()<br>optimizer_content.step()<br></code></pre></td></tr></table></figure> <strong>但对于新版本的pytorch，这种优化方式会报错：</strong> &gt; one of the variables needed for gradient computation has been modified by an inplace operation</p><p>这是因为每个loss回传后都需要及时更新对应权值，否则会被梯度归零而无法优化，这也导致了权值已经不同于loss计算时对应的权值，而梯度计算时一般都需要用到权值，也就是<code>modified by an inplace operation</code></p><p><strong>新版本pytorch的backward()加入了inputs参数，该参数能确保loss在回传时只更新特定权值的梯度，于是有了这么一种优化方式：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer_style.zero_grad()<br>optimizer_adv.zero_grad()<br>optimizer_content.zero_grad()<br><br>loss_cls_style.backward(retain_graph=<span class="hljs-literal">True</span>, inputs=style_params)<br>loss_adv.backward(retain_graph=<span class="hljs-literal">True</span>, inputs=adv_params)<br>loss_cls_content.backward(inputs=content_params)<br><br>optimizer_content.step()<br>optimizer_style.step()<br>optimizer_adv.step()<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Manacher算法</title>
    <link href="/2022/07/15/Manacher/"/>
    <url>/2022/07/15/Manacher/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="马拉车算法">马拉车算法</h1><h2 id="最长回文子串的朴素解法">最长回文子串的朴素解法</h2><blockquote><p>回文串：如果一个长度为n的字符串<span class="math inline">\(s\)</span>为回文串，<span class="math inline">\(n\)</span>可为奇数或偶数，对应两种情况：</p></blockquote><blockquote><p><span class="math inline">\(n\)</span>为奇数时，回文中心为<span class="math inline">\(C\)</span>, 回文半径为<span class="math inline">\(R\)</span>，<span class="math inline">\(\forall i \in [0, R), \, s[C-i] = s[C+i], \, 2R+1=n\)</span></p></blockquote><blockquote><p><span class="math inline">\(n\)</span>为偶数时，回文中心为<span class="math inline">\(C_1, C_2\)</span>，回文半径为<span class="math inline">\(R\)</span>，<span class="math inline">\(\forall i \in [0, R), \, s[C_1-i] = s[C_2+i], \, 2R=n\)</span></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">preProcess</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>    string ret = <span class="hljs-string">&quot;^&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch: s) &#123;<br>        ret += <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ret += ch;<br>    &#125;<br>    ret += <span class="hljs-string">&quot;#$&quot;</span>;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    string sx = <span class="hljs-built_in">preProcess</span>(s);<br>    <span class="hljs-type">int</span> n = sx.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">P</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> C = <span class="hljs-number">0</span>, R = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> mirror_i = <span class="hljs-number">2</span> * C - i;<br>        <span class="hljs-keyword">if</span> (R &gt; i) P[i] = <span class="hljs-built_in">min</span>(P[mirror_i], R - i);<br>        <span class="hljs-keyword">while</span> (sx[i-P[i]<span class="hljs-number">-1</span>] == sx[i+P[i]+<span class="hljs-number">1</span>]) ++P[i];<br>        <span class="hljs-keyword">if</span> (i + P[i] &gt; R) &#123;<br>            C = i;<br>            R = i + P[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> max_len = <span class="hljs-number">0</span>, max_id = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (P[i] &gt; max_len) &#123;<br>            max_len = P[i];<br>            max_id = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> st = (max_id - max_len) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(st, max_len);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深入了解算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/03/17/KMP/"/>
    <url>/2022/03/17/KMP/</url>
    
    <content type="html"><![CDATA[<p>首发于<a href="https://blog.csdn.net/qq_39953680/article/details/123290394?spm=1001.2014.3001.5501">CSDN</a></p><span id="more"></span><h1 id="kmp算法">KMP算法</h1><h2 id="next数组构建">next数组构建</h2><blockquote><p><strong>定义：</strong> 对于字符串<span class="math inline">\(p\)</span>，<span class="math inline">\(next[i]\)</span>表示<span class="math inline">\(p\)</span>在<span class="math inline">\([0, i]\)</span>上的子串的最长相同前后缀长度</p></blockquote><blockquote><p><strong>暴力求解：</strong> 很明显，可以在<span class="math inline">\([0, i)\)</span>上枚举长度来构建<span class="math inline">\(next\)</span>，此时算法复杂度为<span class="math inline">\(O(m^2)\)</span>，<span class="math inline">\(m\)</span>为<span class="math inline">\(p\)</span>的长度</p></blockquote><blockquote><p><strong>优化求解：</strong> 见到最长两字容易想到使用递推也就是动态规划去求解，此时状态就是next数组的定义；求解<span class="math inline">\(next[i]\)</span>时已知字串<span class="math inline">\([0, i-1]\)</span>的最长相同前后缀长度<span class="math inline">\(next[i-1]=j\)</span>，也就是说该子串对应前缀为子串<span class="math inline">\([0, j)\)</span>；此时出现两种情况：</p></blockquote><blockquote><ol type="1"><li><span class="math inline">\(p[j]=p[i]\)</span>，有<span class="math inline">\(next[i]=next[i-1]+1;\)</span> <img src="/img/KMP/next_equal.png" alt="next_equal" /></li></ol></blockquote><blockquote><ol start="2" type="1"><li><span class="math inline">\(p[j] \neq p[i]\)</span>，此时需要 <span class="label label-primary">不断缩短子串$[0, j)$，找到子串$[0, i)$上的次长相同前后缀长度</span>， 但我们只知道最长相同前后缀长度<span class="math inline">\(next[i-1]\)</span>；但不难由<span class="math inline">\(next[i-1]=j\)</span>得子串<span class="math inline">\([0, j)\)</span>等于子串<span class="math inline">\([i-j, i)\)</span>，而子串<span class="math inline">\([0, i)\)</span>的次长相同前后缀的前缀必定落在子串<span class="math inline">\([0, j)\)</span>上、后缀必定落在子串<span class="math inline">\([i-j, i)\)</span>上，设子串<span class="math inline">\([0, i-1]\)</span>的次长相同前后缀为<span class="math inline">\([0, k), [i-k, i)\)</span>， <span class="label label-primary">则有子串$[k, j)==[i-k, i)==[0, k)$，求解子串$[0, i)$次长相同前后缀问题可转化为求解子串$[0, j)$的最长相同前后缀，也就是$next[j-1]$</span>； 不断递归<span class="math inline">\(j=next[j-1]\)</span>直至<span class="math inline">\(p[j]==p[i]\)</span>或<span class="math inline">\(j==0\)</span>，要么没找到相同字符，此时<span class="math inline">\(next[i]=0\)</span>，要么找到了，此时<span class="math inline">\(next[i]=j+1\)</span>； <img src="/img/KMP/next_not_equal.png" alt="next_not_equal" /> 此时根据均摊分析可知复杂度为<span class="math inline">\(O(m)\)</span></li></ol></blockquote><h2 id="字符串匹配">字符串匹配</h2><blockquote><p><strong>首先想到的还是暴力求解：</strong>每次匹配失败时指针<span class="math inline">\(i\)</span>在主串<span class="math inline">\(S\)</span>上回到初始位置并向后移动一格，指针<span class="math inline">\(j\)</span> 在模式串<span class="math inline">\(P\)</span>上回到初始位置 <img src="/img/KMP/match_rude.png" alt="match_rude" /></p></blockquote><blockquote><p>由上图可知这种移动方式是非常耗时的，因为字符<span class="math inline">\(c\)</span>在前面几个字符<span class="math inline">\(ab\)</span>中并没有出现，完全可以直接将模式串<span class="math inline">\(P\)</span>相对于主串<span class="math inline">\(S\)</span>移动到指针<span class="math inline">\(i\)</span>指向的字符<span class="math inline">\(a\)</span>处。 <img src="/img/KMP/match_rude_move.png" alt="match_rude_move" /></p></blockquote><blockquote><p><strong>优化求解：</strong> 对于指针<span class="math inline">\(j\)</span>，<span class="math inline">\(next[j-1]\)</span>表示子串<span class="math inline">\([0, j-1]\)</span>的最长相同前后缀；</p></blockquote><blockquote><p>如果<span class="math inline">\(next[j-1]=0\)</span>，意味着 <span class="label label-primary">字符$P[j-1]$不会出现在$P[0, j-2]$上，而且因为$P$和$S$已部分匹配</span>， 有<span class="math inline">\(S[i-j, i-1]=P[0, j-1]\)</span>，因此有<span class="math inline">\(\forall k \in [0, j-2], P[k] \neq S[i-1]\)</span>，即模式串<span class="math inline">\(P\)</span>相对于主串 <span class="math inline">\(S\)</span>移动<span class="math inline">\([1, j-2]\)</span>位， <span class="label label-primary">都不会把$S[i-1]$匹配上</span>， 这时候就可以把<span class="math inline">\(S[i-1]\)</span>放弃掉，此时对应的就是上面那种情况。</p></blockquote><blockquote><p>对于一般的<span class="math inline">\(next[j-1] \neq 0\)</span>，如下图，此时<span class="math inline">\(next[j-1]=2\)</span> ，同样的也有<span class="math inline">\(S[i-j, i-1]=P[0, j-1]\)</span>，因此有 <span class="label label-primary">$P[j-2, j-1] = S[i-2, i-1] = P[0, 1]$</span>， 也就是说 <span class="label label-primary">$P[0]$和$P[1]$ 是能够匹配上$S[i-2]$和$S[i-1]$的</span>， 可以将<span class="math inline">\(P\)</span>相对于<span class="math inline">\(S\)</span>移动到该位置继续匹配<span class="math inline">\(S[i]\)</span>和<span class="math inline">\(P[j]\)</span> ，如下图①和②； <img src="/img/KMP/match_kmp.png" alt="match_kmp" /></p></blockquote><blockquote><p>但此时<span class="math inline">\(S[i]\)</span>和<span class="math inline">\(P[j]\)</span>依旧没有匹配上，且有<span class="math inline">\(next[j-1] = 1\)</span> ，继续移动，如上图②和③，<span class="math inline">\(S[i]\)</span>和<span class="math inline">\(P[j]\)</span>终于匹配上了，且随着<span class="math inline">\(i\)</span>和<span class="math inline">\(j\)</span>同时继续往下走，模式串<span class="math inline">\(P\)</span>终于匹配上主串<span class="math inline">\(S\)</span>；</p></blockquote><blockquote><p>这个过程中存在一个递归关系<span class="math inline">\(j=next[j-1]\)</span>，且递归终止条件为<span class="math inline">\(j==0 || S[i] == P[j]\)</span> ， <span class="label label-primary">这里的递归公式与动态求解 $next$ 数组一致</span>， 这个过程中<span class="math inline">\(j\)</span>越来越小也就是说相对于初始位置、<span class="math inline">\(P\)</span>相对于<span class="math inline">\(S\)</span>移动的量越来越大， <span class="label label-primary">能够排除暴力求解中的一些情况的同时不漏掉所有可能匹配上的情况</span>。</p></blockquote><h2 id="cpp代码">CPP代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>    <span class="hljs-type">int</span> m = needle.<span class="hljs-built_in">size</span>(), n = haystack.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[i] != needle[j]) j = next[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span> (needle[i] == needle[j]) ++j;<br>        next[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) j = next[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>            ++j;<br>            <span class="hljs-keyword">if</span> (j == m) <span class="hljs-keyword">return</span> i-m+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深入了解算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/03/17/muduo-EventLoopThread/"/>
    <url>/2022/03/17/muduo-EventLoopThread/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="eventloopthread类">EventLoopThread类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopThread</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    EventLoop *loop_;<br>    Thread thread_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">EventLoop* <span class="hljs-title">startLoop</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>muduo库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EventLoopThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
