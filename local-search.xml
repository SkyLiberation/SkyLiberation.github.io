<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入了解muduo库：总览</title>
    <link href="/2022/11/02/muduo%E6%80%BB%E8%A7%88/"/>
    <url>/2022/11/02/muduo%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>深入了解muduo库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>muduo库总览</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解muduo库：EventLoop类</title>
    <link href="/2022/11/02/muduo-EventLoop/"/>
    <url>/2022/11/02/muduo-EventLoop/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="eventloop类">EventLoop类</h1><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">EventLoopThread</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">using</span> ChannelList <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Channel<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">;</span>    ChannelList activeChannels_<span class="token punctuation">;</span>    <span class="token keyword">int</span> wakeupFd_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">using</span> Functor <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">;</span>    EventLoop<span class="token operator">*</span> <span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">runInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">queueInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="queueinloop">queueInLoop()</h2><p><code>queueInLoop</code>有两个作用：一是供该loop所属线程调用（在写操作完成时，线程并不会马上执行写回调函数，而是先放入队列，目的是为了尽快执行完本次epoll_wait返回的事件，避免写回调事件占用时间过长而影响服务端对客户端的响应）；二是供其他线程调用，将回调函数放入队列，并唤醒该loop所属线程，让它亲自执行回调函数（同样是基于<code>one loop per thread</code>思想） <figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">EventLoop</span><span class="token double-colon punctuation">::</span><span class="token function">queueInLoop</span><span class="token punctuation">(</span>Functor cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">></span> <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>        pendingFunctors_<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isInLoopThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> callingPendingFunctors_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p><h2 id="loop">loop</h2><p><code>loop</code>是工作线程的主要执行函数，每次<code>epoll_wait</code>返回时（其他线程唤醒本线程同样通过epoll_wait）执行一轮循环，处理<code>epoll_wait</code>返回的事件以及调用<code>queueInloop</code>放入队列中的回调函数 <figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>quit_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    activeChannels_<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pollReturnTime_ <span class="token operator">=</span> poller_<span class="token operator">-></span><span class="token function">poll</span><span class="token punctuation">(</span>kPollTimeMs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>activeChannels_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Channel <span class="token operator">*</span>channel <span class="token operator">:</span> activeChannels_<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        channel<span class="token operator">-></span><span class="token function">handleEvent</span><span class="token punctuation">(</span>pollReturnTime_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">doPendingFunctors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p>]]></content>
    
    
    <categories>
      
      <category>深入了解muduo库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>muduo库EventLoop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入了解muduo库：EventLoopThread类</title>
    <link href="/2022/10/26/muduo-EventLoopThread/"/>
    <url>/2022/10/26/muduo-EventLoopThread/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="eventloopthread类">EventLoopThread类</h1><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">EventLoopThread</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span>    EventLoop <span class="token operator">*</span>loop_<span class="token punctuation">;</span>    Thread thread_<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    EventLoop<span class="token operator">*</span> <span class="token function">startLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h2 id="startloop">startLoop()</h2><p><code>one loop per thread</code> 是moduo库设计的核心思想，为了保证这一点，<code>EventLoop</code> 类有一个成员<code>const pid_t threadId_</code>，记录创建该loop的线程id，表示该loop属于某一特定线程；以后可能会出现其他线程调用该loop的 <code>public</code> 函数的情况（特别是主线程调用工作线程的loop），这时候就要用这个 <code>threadId_</code> 对比当前调用线程id，如果不一致需唤醒对应线程，让它来调用；</p><p><code>startLoop()</code> 会在线程池生成工作线程时被调用，它的调用者是主线程，由于loop的<code>threadId_</code> 是<code>const</code>类型，只能在构造函数处被初始化且不能被另外修改，因此loop只能在工作线程处创建，而<code>EventLoopThread</code> 类中的<code>EventLoop *loop_</code> 成员指向了该loop，该成员的赋值就在<code>startLoop()</code> 内，这里就涉及到了主线程和工作线程同步问题（主线程需要在工作线程完成loop创建后才能进行赋值），也就有了下面的代码： <figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 主线程调用的startLoop()内</span>EventLoop<span class="token operator">*</span> loop <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#123;</span>    MutexLockGuard <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>loop_ <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cond_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    loop <span class="token operator">=</span> loop_<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 工作线程的回调函数</span>EventLoop loop<span class="token punctuation">;</span> <span class="token comment">// 工作线程创建loop</span><span class="token punctuation">&#123;</span>    MutexLockGuard <span class="token function">lock</span><span class="token punctuation">(</span>mutex_<span class="token punctuation">)</span><span class="token punctuation">;</span>    loop_ <span class="token operator">=</span> <span class="token operator">&amp;</span>loop<span class="token punctuation">;</span>    cond_<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>loop<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// loop开启事件循环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p>]]></content>
    
    
    <categories>
      
      <category>深入了解muduo库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>muduo库EventLoopThread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch Loss优化</title>
    <link href="/2022/07/15/Pytorch%20Loss/"/>
    <url>/2022/07/15/Pytorch%20Loss/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch-loss优化">Pytorch Loss优化</h1><span id="more"></span><h2 id="问题引入">问题引入</h2><p>考虑这么一个网络的优化： <img src="/img/Loss/network.png" alt="network" /> 整个网络由3个loss优化(<code>loss_cls_content, loss_adv, loss_cls_style</code>)，其中<code>loss_cls_content</code>只优化<code>Feature Extractor(Content) Block1, Feature Extractor(Content) Block1, ClsHead(Content)</code>（黄色虚线框框住的模块）、<code>loss_adv</code>只优化<code>Feature Extractor(Content) Block1</code>（红色虚线框框住的模块）、<code>loss_cls_style</code>只优化<code>Feature Extractor(Content) Block2, ClsHead(Style)</code>（绿色虚线框框住的模块）。 ## 如何进行梯度回传 定义三个优化器<code>optimizer_content, optimizer_style, optimizer_adv</code>，分别优化三个虚线框内模块的参数；</p><p><strong>容易想到这么一种优化方法：</strong> <figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 如果不考虑使用detach()进行模块隔绝（实际上detach对这个网络的优化也无能为力），三个loss在回传过程中都会影响到不希望影响到的模块</span><span class="token comment"># 考虑使用三个优化器，只优化对应模块的参数，三个loss分别回传，优化前都会进行梯度归零、回传后马上更新权值，即可达到想要的优化效果</span>optimizer_style<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>loss_cls_style<span class="token punctuation">.</span>backward<span class="token punctuation">(</span>retain_graph<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>optimizer_style<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_adv<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>loss_adv<span class="token punctuation">.</span>backward<span class="token punctuation">(</span>retain_graph<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>optimizer_adv<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_content<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>loss_cls_content<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_content<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure> <strong>但对于新版本的pytorch，这种优化方式会报错：</strong> &gt; one of the variables needed for gradient computation has been modified by an inplace operation</p><p>这是因为每个loss回传后都需要及时更新对应权值，否则会被梯度归零而无法优化，这也导致了权值已经不同于loss计算时对应的权值，而梯度计算时一般都需要用到权值，也就是<code>modified by an inplace operation</code></p><p><strong>新版本pytorch的backward()加入了inputs参数，该参数能确保loss在回传时只更新特定权值的梯度，于是有了这么一种优化方式：</strong> <figure><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python">optimizer_style<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_adv<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_content<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>loss_cls_style<span class="token punctuation">.</span>backward<span class="token punctuation">(</span>retain_graph<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> inputs<span class="token operator">=</span>style_params<span class="token punctuation">)</span>loss_adv<span class="token punctuation">.</span>backward<span class="token punctuation">(</span>retain_graph<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> inputs<span class="token operator">=</span>adv_params<span class="token punctuation">)</span>loss_cls_content<span class="token punctuation">.</span>backward<span class="token punctuation">(</span>inputs<span class="token operator">=</span>content_params<span class="token punctuation">)</span>optimizer_content<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_style<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer_adv<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></p>]]></content>
    
    
    <categories>
      
      <category>Pytorch</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Manacher算法</title>
    <link href="/2022/07/15/Manacher/"/>
    <url>/2022/07/15/Manacher/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="马拉车算法">马拉车算法</h1><h2 id="最长回文子串的朴素解法">最长回文子串的朴素解法</h2><blockquote><p>回文串：如果一个长度为n的字符串<code>s</code>为回文串，<code>n</code>可为奇数或偶数，对应两种情况：</p></blockquote><blockquote><p><code>n</code>为奇数时，回文中心为<code>C</code>, 回文半径为<code>R</code>：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>s</mi><mo stretchy="false">[</mo><mi>C</mi><mo>−</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><mi>C</mi><mo>+</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mi>R</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\forall i \in [0, R), \, s[C-i] = s[C+i], \, 2R+1=n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p></blockquote><blockquote><p><code>n</code>为偶数时，回文中心为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_1, C_2 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，回文半径为<code>R</code>：<br /><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>s</mi><mo stretchy="false">[</mo><msub><mi>C</mi><mn>1</mn></msub><mo>−</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>s</mi><mo stretchy="false">[</mo><msub><mi>C</mi><mn>2</mn></msub><mo>+</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mi>R</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\forall i \in [0, R), \, s[C_1-i] = s[C_2+i], \, 2R=n </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span></p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">preProcess</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string ret <span class="token operator">=</span> <span class="token string">"^"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> ch<span class="token operator">:</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ret <span class="token operator">+=</span> <span class="token char">'#'</span><span class="token punctuation">;</span>        ret <span class="token operator">+=</span> ch<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ret <span class="token operator">+=</span> <span class="token string">"#$"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>string <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string sx <span class="token operator">=</span> <span class="token function">preProcess</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> sx<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">P</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> C <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> R <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mirror_i <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> C <span class="token operator">-</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>R <span class="token operator">></span> i<span class="token punctuation">)</span> P<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>P<span class="token punctuation">[</span>mirror_i<span class="token punctuation">]</span><span class="token punctuation">,</span> R <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>sx<span class="token punctuation">[</span>i<span class="token operator">-</span>P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> sx<span class="token punctuation">[</span>i<span class="token operator">+</span>P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> P<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> R<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            C <span class="token operator">=</span> i<span class="token punctuation">;</span>            R <span class="token operator">=</span> i <span class="token operator">+</span> P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> max_len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max_len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            max_len <span class="token operator">=</span> P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            max_id <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> st <span class="token operator">=</span> <span class="token punctuation">(</span>max_id <span class="token operator">-</span> max_len<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> max_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>深入了解算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法</title>
    <link href="/2022/03/17/KMP/"/>
    <url>/2022/03/17/KMP/</url>
    
    <content type="html"><![CDATA[<p>首发于<a href="https://blog.csdn.net/qq_39953680/article/details/123290394?spm=1001.2014.3001.5501">CSDN</a></p><span id="more"></span><h1 id="kmp算法">KMP算法</h1><h2 id="next数组构建">next数组构建</h2><blockquote><p><strong>定义：</strong> 对于字符串<code>p</code>，<code>next[i]</code>表示<code>p</code>在<code>[0, i]</code>上的子串的最长相同前后缀长度</p></blockquote><blockquote><p><strong>暴力求解：</strong> 很明显，可以在<code>[0, i)</code>上枚举长度来构建<code>next</code>，此时算法复杂度为<code>O(m^2)</code>，<code>m</code>为<code>p</code>的长度</p></blockquote><blockquote><p><strong>优化求解：</strong> 见到最长两字容易想到使用递推也就是动态规划去求解，此时状态就是next数组的定义；求解<code>next[i]</code>时已知字串<code>[0, i-1]</code>的最长相同前后缀长度<code>next[i-1]=j</code>，也就是说该子串对应前缀为子串<code>[0, j)</code>；此时出现两种情况：</p></blockquote><blockquote><ol type="1"><li><code>p[j] = p[i]</code>，有<code>next[i] = next[i-1]+1</code>； <img src="/img/KMP/next_equal.png" alt="next_equal" /></li></ol></blockquote><blockquote><ol start="2" type="1"><li><code>p[j] != p[i]</code>，此时需要 <span class="label label-primary">不断缩短子串[0, j)，找到子串[0, i)上的次长相同前后缀长度</span>， 但我们只知道最长相同前后缀长度<code>next[i-1]</code>；但不难由<code>next[i-1] = j</code>得子串<code>[0, j)</code>等于子串<code>[i-j, i)</code>，而子串<code>[0, i)</code>的次长相同前后缀的前缀必定落在子串<code>[0, j)</code>上、后缀必定落在子串<code>[i-j, i)</code>上，设子串<code>[0, i-1]</code>的次长相同前后缀为<code>[0, k)</code>和<code>[i-k, i)</code>， <span class="label label-primary">则有子串[k, j)==[i-k, i)==[0, k)，求解子串[0, i)次长相同前后缀问题可转化为求解子串[0, j)的最长相同前后缀，也就是next[j-1]</span>； 不断递归<code>j = next[j-1]</code>直至<code>p[j] == p[i]</code>或<code>j == 0</code>，要么没找到相同字符，此时<code>next[i] = 0</code>，要么找到了，此时<code>next[i] =s j+1</code>； <img src="/img/KMP/next_not_equal.png" alt="next_not_equal" /> 此时根据均摊分析可知复杂度为<code>O(m)</code></li></ol></blockquote><h2 id="字符串匹配">字符串匹配</h2><blockquote><p><strong>首先想到的还是暴力求解：</strong>每次匹配失败时指针<code>i</code>在主串<code>S</code>上回到初始位置并向后移动一格，指针<code>j</code>在模式串<code>P</code>上回到初始位置 <img src="/img/KMP/match_rude.png" alt="match_rude" /></p></blockquote><blockquote><p>由上图可知这种移动方式是非常耗时的，因为字符<code>c</code>在前面几个字符<code>ab</code>中并没有出现，完全可以直接将模式串<code>P</code>相对于主串<code>S</code>移动到指针<code>i</code>指向的字符<code>a</code>处。 <img src="/img/KMP/match_rude_move.png" alt="match_rude_move" /></p></blockquote><blockquote><p><strong>优化求解：</strong> 对于指针<code>j</code>，<code>next[j-1]</code>表示子串<code>[0, j-1]</code>的最长相同前后缀；</p></blockquote><blockquote><p>如果<code>next[j-1] = 0</code>，意味着 <span class="label label-primary">字符P[j-1]不会出现在P[0, j-2]上，而且因为P和S已部分匹配</span>， 有<code>S[i-j, i-1] = P[0, j-1]</code>，因此有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>k</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>P</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo mathvariant="normal">≠</mo><mi>S</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\forall k \in [0, j-2], P[k] \neq S[i-1] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord">∀</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，即模式串<code>P</code>相对于主串 <code>S</code>移动<code>[1, j-2]</code>位， <span class="label label-primary">都不会把S[i-1]匹配上</span>， 这时候就可以把<code>S[i-1]</code>放弃掉，此时对应的就是上面那种情况。</p></blockquote><blockquote><p>对于一般的<code>next[j-1] != 0</code>，如下图，此时<code>next[j-1] = 2</code>，同样的也有<code>S[i-j, i-1] = P[0, j-1]</code>，因此有 <span class="label label-primary">P[j-2, j-1] = S[i-2, i-1] = P[0, 1]</span>， 也就是说 <span class="label label-primary">P[0]和P[1]是能够匹配上S[i-2]和S[i-1]的</span>， 可以将<code>P</code>相对于<code>S</code>移动到该位置继续匹配<code>S[i]</code>和<code>P[j]</code>，如下图①和②； <img src="/img/KMP/match_kmp.png" alt="match_kmp" /></p></blockquote><blockquote><p>但此时<code>S[i]</code>和<code>P[j]</code>依旧没有匹配上，且有<code>next[j-1] = 1</code>，继续移动，如上图②和③，<code>S[i]</code>和<code>P[j]</code>终于匹配上了，且随着<code>i</code>和<code>j</code>同时继续往下走，模式串<code>P</code>终于匹配上主串<code>S</code>；</p></blockquote><blockquote><p>这个过程中存在一个递归关系<code>j = next[j-1]</code>，且递归终止条件为<code>j==0 || S[i] == P[j]</code> ， <span class="label label-primary">这里的递归公式与动态求解 next数组一致</span>， 这个过程中<code>j</code>越来越小也就是说相对于初始位置、<code>P</code>相对于<code>S</code>移动的量越来越大， <span class="label label-primary">能够排除暴力求解中的一些情况的同时不漏掉所有可能匹配上的情况</span>。</p></blockquote><h2 id="cpp代码">CPP代码</h2><figure><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>string haystack<span class="token punctuation">,</span> string needle<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> needle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> haystack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">next</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> needle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needle<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">++</span>j<span class="token punctuation">;</span>        next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>haystack<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> needle<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token operator">-</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>]]></content>
    
    
    <categories>
      
      <category>深入了解算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
